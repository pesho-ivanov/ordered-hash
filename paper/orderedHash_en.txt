
** Ordered hash data structure

  For now on we will call a key a specific hashable and comparable object and we will call a data any specific object.

  The introduced data structure Ordered hash consists of a balanced search tree [???] T and a hash map H [???]. The main aim of integrating a hash table to a search tree is to speed-up the find operation while dynamically maintaining the order of the elements in the tree. Each element of T contains a key field (by which it is ordered) and a data field. H maps keys to address pointers to T elements.

The main operations of the introduced ordered_hash work as follows:
 -- insert(key, value):
    1) inserts the (key, value) pair into T as an element pointed by p,
    2) inserts the (key, p) pair into H.
 -- find(key):
    1) searches for key in H
    2) if key is found in H then returns a pointer to key in T
 -- erase(key):
    1) erases key from H
    2) erases key from T
 -- next(T-pointer) and prev(T-pointer)
    1) returns the next/prev pointer

** Implementation details
  The proposed C++ class ordered_hash is fully STL-consistent. It has the same interface as STL map so as to be easily interchanged in existing projects. The class ordered_hash is templated by key_type and data_type. The type ordered_t of T is defined by the STL map<key_type, data_type>. The type unordered_t of H is defined by the STL unordered_map<key_type, ordered_t::iterator>. (Note that the map specification guarantees that elements do not change their address.)

  The overhead memory usage of this implementation against map is about Theta(N)
  Memory optimization:
    H: key->iterator    ---->    H: key_hash->iterator

** Complexities
  All the operations on map are available on ordered_hash with the same time and memory complexities except the find operation which runs in O(1). Note that if the number of elements to be inserted is not known ahead, the complexities of insertion and erasion in hash tables are only amortized O(1) over multiple calls (because of hash table resizing).
  The insertion into ordered_hash consists of insertion into a map for O(logN) and insertion into a hash for O(1).
  The transitions to the next and to the previous element in the ordered set are done traversing the tree. The maximum edge-distance between sequential elements is at most O(logN) but amortized over iterating the whole tree the average distance is O(1) (because every edge is traversed exactly twice -- downwards and upwards).

                 map    ordered_hash  ordered_hash*  hash/unordered_map
      insert:   logN        logN          logN*              1
       erase:   logN        logN           1                 1
        find:   logN         1             1                 1
   next/prev:   logN        logN          logN*           n/a or N
  all sorted:     N          N             N*           n/a or NlogN

** The erase optimization
  Instead of erasing an element from both the hash and the tree, it can be only erased from the hash. Searching for an element will be unsuccessful if the element is not found in the hash. This optimizes the erase operation to O(1). Some additional work not increasing the complexity is to be done when traversing the tree: every element has to be checked on whether it was not erased from the hash. Another implication of not physically erasing elements is that the iteration time is no more dependent on the number of elements N logically contained in the structure but on the number of elements N* ever inserted.

** The next/prev optimization
  It is possible to ...

** Experimental results
   -- toy data
  table with times 

   -- real data
  table with times 

   * ordered_hash finds are much quicker than map finds
   * ordered_hash finds are quicker than hash finds!
   * ordered_hash_faster's find is slower than ordered_hash's
   * ordered_hash_faster has O(1) erase but finds and increments are slower because of the filter_iterator

** Other structures
  The described ordered_hash_map class can be extended to analogous ordered_hash_multimap, ordered_hash_set and ordered_hash_multiset.
  Trie -- not by comparison
